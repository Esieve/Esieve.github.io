<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Esieve&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-23T07:48:25.266Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Esieve</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Boot日志系统改造与源码</title>
    <link href="http://yoursite.com/2019/12/23/Spring-Boot%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E6%94%B9%E9%80%A0%E4%B8%8E%E6%BA%90%E7%A0%81/"/>
    <id>http://yoursite.com/2019/12/23/Spring-Boot日志系统改造与源码/</id>
    <published>2019-12-23T03:34:00.000Z</published>
    <updated>2019-12-23T07:48:25.266Z</updated>
    
    <content type="html"><![CDATA[<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>首页我们需要看下Spring Boot是如何加载不同的日志系统。加载的启动类是<code>LoggingApplicationListener</code>，这里重写了程序启动的一些事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationStartingEvent) &#123;</span><br><span class="line">        onApplicationStartingEvent((ApplicationStartingEvent) event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationEnvironmentPreparedEvent) &#123;</span><br><span class="line">        onApplicationEnvironmentPreparedEvent(</span><br><span class="line">                (ApplicationEnvironmentPreparedEvent) event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationPreparedEvent) &#123;</span><br><span class="line">        onApplicationPreparedEvent((ApplicationPreparedEvent) event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextClosedEvent &amp;&amp; ((ContextClosedEvent) event)</span><br><span class="line">            .getApplicationContext().getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        onContextClosedEvent();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationFailedEvent) &#123;</span><br><span class="line">        onApplicationFailedEvent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已<code>onApplicationStartingEvent</code>函数为例，方法从<code>LoggingSystem</code>获取日志系统。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onApplicationStartingEvent</span><span class="params">(ApplicationStartingEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loggingSystem = LoggingSystem</span><br><span class="line">            .get(event.getSpringApplication().getClassLoader());</span><br><span class="line">    <span class="keyword">this</span>.loggingSystem.beforeInitialize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LoggingSystem</code>定义了一些常用的日志系统，这个是固定的无法修改，我们在使用的时候根据引用的依赖控制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    Map&lt;String, String&gt; systems = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    systems.put(<span class="string">"ch.qos.logback.core.Appender"</span>,</span><br><span class="line">            <span class="string">"org.springframework.boot.logging.logback.LogbackLoggingSystem"</span>);</span><br><span class="line">    systems.put(<span class="string">"org.apache.logging.log4j.core.impl.Log4jContextFactory"</span>,</span><br><span class="line">            <span class="string">"org.springframework.boot.logging.log4j2.Log4J2LoggingSystem"</span>);</span><br><span class="line">    systems.put(<span class="string">"java.util.logging.LogManager"</span>,</span><br><span class="line">            <span class="string">"org.springframework.boot.logging.java.JavaLoggingSystem"</span>);</span><br><span class="line">    SYSTEMS = Collections.unmodifiableMap(systems);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>get</code>方法定义了获取逻辑，可以看到，我们可以通过System Property的方式，自定义我们自己的日志系统，例如<code>System.setProperty(LoggingSystem.class.getName(), &quot;com.test.TestLoggingSystem&quot;);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SYSTEM_PROPERTY = LoggingSystem<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LoggingSystem <span class="title">get</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    String loggingSystem = System.getProperty(SYSTEM_PROPERTY);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(loggingSystem)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (NONE.equals(loggingSystem)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NoOpLoggingSystem();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> get(classLoader, loggingSystem);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SYSTEMS.entrySet().stream()</span><br><span class="line">            .filter((entry) -&gt; ClassUtils.isPresent(entry.getKey(), classLoader))</span><br><span class="line">            .map((entry) -&gt; get(classLoader, entry.getValue())).findFirst()</span><br><span class="line">            .orElseThrow(() -&gt; <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">"No suitable logging system located"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件系统的继承关系如下</p><p><img src="https://i.loli.net/2019/12/23/RQEwS3lZC7zgVDu.png" alt="image.png"></p><p>我们以<code>log4j</code>为例，可以看到默认实现是用<code>ResourceUtils</code>读取，这里我们就可以继承Log4J2LoggingSystem，去重写<code>loadConfiguration</code>方法，比如从zookeeper获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadDefaults</span><span class="params">(LoggingInitializationContext initializationContext,</span></span></span><br><span class="line"><span class="function"><span class="params">        LogFile logFile)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">        loadConfiguration(getPackagedConfigFile(<span class="string">"log4j2-file.xml"</span>), logFile);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        loadConfiguration(getPackagedConfigFile(<span class="string">"log4j2.xml"</span>), logFile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadConfiguration</span><span class="params">(LoggingInitializationContext initializationContext,</span></span></span><br><span class="line"><span class="function"><span class="params">        String location, LogFile logFile)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.loadConfiguration(initializationContext, location, logFile);</span><br><span class="line">    loadConfiguration(location, logFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadConfiguration</span><span class="params">(String location, LogFile logFile)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(location, <span class="string">"Location must not be null"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        LoggerContext ctx = getLoggerContext();</span><br><span class="line">        URL url = ResourceUtils.getURL(location);</span><br><span class="line">        ConfigurationSource source = getConfigurationSource(url);</span><br><span class="line">        ctx.start(ConfigurationFactory.getInstance().getConfiguration(ctx, source));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">"Could not initialize Log4J2 logging from "</span> + location, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ConfigurationSource <span class="title">getConfigurationSource</span><span class="params">(URL url)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStream stream = url.openStream();</span><br><span class="line">    <span class="keyword">if</span> (FILE_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConfigurationSource(stream, ResourceUtils.getFile(url));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConfigurationSource(stream, url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;源码&quot;&gt;&lt;a href=&quot;#源码&quot; class=&quot;headerlink&quot; title=&quot;源码&quot;&gt;&lt;/a&gt;源码&lt;/h2&gt;&lt;p&gt;首页我们需要看下Spring Boot是如何加载不同的日志系统。加载的启动类是&lt;code&gt;LoggingApplicationListene
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Lettuce实践与部分源码分析</title>
    <link href="http://yoursite.com/2019/11/18/Lettuce%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/11/18/Lettuce源码分析/</id>
    <published>2019-11-18T12:23:00.000Z</published>
    <updated>2020-01-02T13:42:30.410Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Boot提供了RedisTemplate对Jedis和Lettuce进行了封装，使得我们可以方便的对两种客户端进行使用和切换。</p><p>Jedis 是直连模式，在多个线程间共享一个 Jedis 实例时是线程不安全的，如果想要在多线程环境下使用 Jedis，需要使用连接池，每个线程都去拿自己的 Jedis 实例，当连接数量增多时，物理连接成本就较高了。</p><p>Lettuce的连接是基于Netty的，连接实例可以在多个线程间共享，所以，一个多线程的应用可以使用同一个连接实例，而不用担心并发线程的数量。当然这个也是可伸缩的设计，一个连接实例不够的情况也可以按需增加连接实例。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><ol><li>Spring Boot通过在application.properties里添加配置，开启Lettuce客户端，<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spring.redis.password=</span><br><span class="line">spring.redis.timeout=</span><br><span class="line">spring.redis.lettuce.pool.max-active=</span><br><span class="line">spring.redis.lettuce.pool.max-wait=</span><br><span class="line">spring.redis.lettuce.pool.max-idle=</span><br><span class="line">spring.redis.lettuce.pool.min-idle=</span><br><span class="line">spring.redis.lettuce.shutdown-timeout=</span><br><span class="line">spring.redis.cluster.nodes=</span><br><span class="line">spring.redis.cluster.max-redirects=</span><br></pre></td></tr></table></figure></li><li>Spring Boot会在扫描配置的时候，提供默认的RedisConnectionFactory实现，这里我们可以重写定制更多策略，最后注入到RedisTemplate中<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(RedisClient<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">// <span class="title">application</span>.<span class="title">properties</span>中添加配置的才创建<span class="title">bean</span></span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnProperty</span>(<span class="title">prefix</span> </span>= <span class="string">"spring.redis"</span>, name = <span class="string">"cluster.nodes"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Duration DEFAULT_TIMEOUT = Duration.ofSeconds(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Duration DEFAULT_REFRESH_PERIOD = Duration.ofSeconds(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(RedisTemplate<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">RedisTemplate</span>&lt;<span class="title">String</span>, <span class="title">Object</span>&gt; <span class="title">redisTemplate</span>(<span class="title">LettuceConnectionFactory</span> <span class="title">redisConnectionFactory</span>) </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        GenericGsonRedisSerializer redisSerializer = <span class="keyword">new</span> GenericGsonRedisSerializer();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        template.setValueSerializer(redisSerializer);</span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        template.setHashValueSerializer(redisSerializer);</span><br><span class="line">        template.setHashKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(RedisConnectionFactory<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">LettuceConnectionFactory</span> <span class="title">redisConnectionFactory</span>(<span class="title">RedisProperties</span> <span class="title">properties</span>) </span>&#123;</span><br><span class="line">        LettuceConnectionFactory factory = <span class="keyword">new</span> LettuceConnectionFactory(getClusterConfiguration(properties), getClientConfiguration(properties));</span><br><span class="line">        <span class="comment">// 使用前先校验连接</span></span><br><span class="line">        factory.setValidateConnection(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisClusterConfiguration <span class="title">getClusterConfiguration</span><span class="params">(RedisProperties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (properties.getCluster() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RedisProperties.Cluster clusterProperties = properties.getCluster();</span><br><span class="line">        RedisClusterConfiguration config = <span class="keyword">new</span> RedisClusterConfiguration(clusterProperties.getNodes());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clusterProperties.getMaxRedirects() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            config.setMaxRedirects(clusterProperties.getMaxRedirects());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (properties.getPassword() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            config.setPassword(RedisPassword.of(properties.getPassword()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LettuceClientConfiguration <span class="title">getClientConfiguration</span><span class="params">(RedisProperties properties)</span> </span>&#123;</span><br><span class="line">        GenericObjectPoolConfig config = <span class="keyword">new</span> GenericObjectPoolConfig();</span><br><span class="line"></span><br><span class="line">        RedisProperties.Pool pool = properties.getLettuce().getPool();</span><br><span class="line"></span><br><span class="line">        config.setMaxTotal(pool.getMaxIdle());</span><br><span class="line">        config.setMaxIdle(pool.getMaxIdle());</span><br><span class="line">        config.setMinIdle(pool.getMinIdle());</span><br><span class="line">        config.setMaxWaitMillis(pool.getMaxWait().toMillis());</span><br><span class="line">        <span class="comment">// 取连接时校验</span></span><br><span class="line">        config.setTestOnBorrow(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 空闲时校验</span></span><br><span class="line">        config.setTestWhileIdle(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于redis cluster，如果某个节点失效，我们需要配置定期刷新和适应性刷新，及时更新拓扑</span></span><br><span class="line">        ClusterClientOptions clusterClientOptions = ClusterClientOptions.builder()</span><br><span class="line">                .topologyRefreshOptions(ClusterTopologyRefreshOptions.builder()</span><br><span class="line">                        .enablePeriodicRefresh()</span><br><span class="line">                        .refreshPeriod(DEFAULT_REFRESH_PERIOD)</span><br><span class="line">                        .enableAllAdaptiveRefreshTriggers()</span><br><span class="line">                        .build())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> LettucePoolingClientConfiguration.builder()</span><br><span class="line">                .commandTimeout(properties.getTimeout() == <span class="keyword">null</span> ? DEFAULT_TIMEOUT : properties.getTimeout())</span><br><span class="line">                .poolConfig(config)</span><br><span class="line">                <span class="comment">// Lettuce提供了多种读取策略，我们可以从slave读，fallback到master，适合实时性要求不高，保证最终一致性</span></span><br><span class="line">                .readFrom(ReadFrom.REPLICA_PREFERRED)</span><br><span class="line">                .clientOptions(clusterClientOptions)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="默认RedisConnectionFactory"><a href="#默认RedisConnectionFactory" class="headerlink" title="默认RedisConnectionFactory"></a>默认RedisConnectionFactory</h3>spring-boot-autoconfigure会创建一个默认的RedisConnectionFactory，在LettuceConnectionConfiguration类里<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(RedisConnectionFactory<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">LettuceConnectionFactory</span> <span class="title">redisConnectionFactory</span>(<span class="title">ClientResources</span> <span class="title">clientResources</span>)</span></span><br><span class="line"><span class="class">        <span class="title">throws</span> <span class="title">UnknownHostException</span> </span>&#123;</span><br><span class="line">    LettuceClientConfiguration clientConfig = getLettuceClientConfiguration(clientResources,</span><br><span class="line">            <span class="keyword">this</span>.properties.getLettuce().getPool());</span><br><span class="line">    <span class="keyword">return</span> createLettuceConnectionFactory(clientConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3>Lettuce的连接池使用了GenericObjectPool存放，</li></ol><p>LettuceConnectionFactory里开启了<code>factory.setValidateConnection(true)</code>，使用前会ping一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">validateConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.connectionMonitor) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> valid = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; connection.isOpen()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (connection <span class="keyword">instanceof</span> StatefulRedisConnection) &#123;</span><br><span class="line">                    ((StatefulRedisConnection) connection).sync().ping();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (connection <span class="keyword">instanceof</span> StatefulRedisClusterConnection) &#123;</span><br><span class="line">                    ((StatefulRedisClusterConnection) connection).sync().ping();</span><br><span class="line">                &#125;</span><br><span class="line">                valid = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.debug(<span class="string">"Validation failed"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">            log.warn(<span class="string">"Validation of shared connection failed. Creating a new connection."</span>);</span><br><span class="line">            resetConnection();</span><br><span class="line">            <span class="keyword">this</span>.connection = getNativeConnection();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LettuceConnectionFactory，创建connectionProvider封装连接的获取<br>这里注意调用afterPropertiesSet方法完成后续成员的初始化，所以要给自定义的LettuceConnectionFactory，创建connectionProvider封装连接的获取加@Bean注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.client = createClient();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.connectionProvider = createConnectionProvider(client, CODEC);</span><br><span class="line">    <span class="keyword">this</span>.reactiveConnectionProvider = createConnectionProvider(client, LettuceReactiveRedisConnection.CODEC);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isClusterAware()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.clusterCommandExecutor = <span class="keyword">new</span> ClusterCommandExecutor(</span><br><span class="line">                <span class="keyword">new</span> LettuceClusterTopologyProvider((RedisClusterClient) client),</span><br><span class="line">                <span class="keyword">new</span> LettuceClusterConnection.LettuceClusterNodeResourceProvider(<span class="keyword">this</span>.connectionProvider),</span><br><span class="line">                EXCEPTION_TRANSLATION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getEagerInitialization() &amp;&amp; getShareNativeConnection()) &#123;</span><br><span class="line">        initConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LettucePoolingConnectionProvider，从GenericObjectPool连接池取连接，如果开启了testOnBorrow，取得时候会检查连通性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends StatefulConnection&lt;?, ?&gt;&gt; <span class="function">T <span class="title">getConnection</span><span class="params">(Class&lt;T&gt; connectionType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    GenericObjectPool&lt;StatefulConnection&lt;?, ?&gt;&gt; pool = pools.computeIfAbsent(connectionType, poolType -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> ConnectionPoolSupport.createGenericObjectPool(() -&gt; connectionProvider.getConnection(connectionType),</span><br><span class="line">                poolConfig, <span class="keyword">false</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        StatefulConnection&lt;?, ?&gt; connection = pool.borrowObject();</span><br><span class="line"></span><br><span class="line">        poolRef.put(connection, pool);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> connectionType.cast(connection);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> PoolException(<span class="string">"Could not get a resource from the pool"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConnectionPoolSupport里有校验的方法，判断了一下标志位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisPooledObjectFactory</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">StatefulConnection</span>&lt;?, ?&gt;&gt; <span class="keyword">extends</span> <span class="title">BasePooledObjectFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Supplier&lt;T&gt; connectionSupplier;</span><br><span class="line"></span><br><span class="line">    RedisPooledObjectFactory(Supplier&lt;T&gt; connectionSupplier) &#123;</span><br><span class="line">        <span class="keyword">this</span>.connectionSupplier = connectionSupplier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">create</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> connectionSupplier.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyObject</span><span class="params">(PooledObject&lt;T&gt; p)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        p.getObject().close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PooledObject&lt;T&gt; <span class="title">wrap</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultPooledObject&lt;&gt;(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateObject</span><span class="params">(PooledObject&lt;T&gt; p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p.getObject().isOpen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring Boot提供了RedisTemplate对Jedis和Lettuce进行了封装，使得我们可以方便的对两种客户端进行使用和切换。&lt;/p&gt;
&lt;p&gt;Jedis 是直连模式，在多个线程间共享一个 Jedis 实例时是线程不安全的，如果想要在多线程环境下使用 Jedis
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Spring Boot使用Zookeeper分发configuration</title>
    <link href="http://yoursite.com/2019/01/08/Spring-Boot%E7%9B%91%E5%90%ACzookeeper%E4%BF%AE%E6%94%B9/"/>
    <id>http://yoursite.com/2019/01/08/Spring-Boot监听zookeeper修改/</id>
    <published>2019-01-08T03:34:00.000Z</published>
    <updated>2019-12-08T04:41:58.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="intro"><a href="#intro" class="headerlink" title="intro"></a>intro</h1><p>Configuration 在特殊的“bootstrap”阶段加载到 Spring 环境中。Bootstrap属于引导配置，Application属于应用配置。</p><blockquote><ol><li>bootstrap 由父ApplicationContext加载，比application优先加载；</li><li>bootstrap里面的属性不能被覆盖；</li></ol></blockquote><p>Configuration 默认存储在/config命名空间中。基于 application 的 name 和 active profiles 创建多个PropertySource实例，以模仿解析 properties 的 Spring Cloud Config order。对于 example，具有 name testApp和dev profile 的 application 具有为其创建的以下 property 源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config/testApp,dev</span><br><span class="line">config/testApp</span><br><span class="line">config/application,dev</span><br><span class="line">config/application</span><br></pre></td></tr></table></figure><p>最具体的 property 源位于顶部，底部最不具体。 config/application名称空间中的 Properties 适用于使用 zookeeper 进行 configuration 的所有 applications。 config/testApp名称空间中的 Properties 仅适用于名为testApp的服务的实例。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>1、引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、添加bootstrap.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">zookeeper:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">root:</span> <span class="string">configuration</span></span><br><span class="line">        <span class="attr">defaultContext:</span> <span class="string">apps</span></span><br><span class="line">        <span class="attr">profileSeparator:</span> <span class="string">'::'</span></span><br></pre></td></tr></table></figure><blockquote><p>enabled：将此 value 设置为false会禁用 Zookeeper 配置。</p><p>root：设置 configuration 值的基本命名空间。</p><p>defaultContext：设置所有 applications 使用的 name。</p><p>profileSeparator：设置用于将 property 源中的 profile name 与 profiles 分隔开的分隔符的 value。</p></blockquote><p>3、配置刷新</p><p>添加<code>@RefreshScope</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"config"</span>)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> testConfig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匹配的zkpath为/config/${service name}/config/test/test-config</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;intro&quot;&gt;&lt;a href=&quot;#intro&quot; class=&quot;headerlink&quot; title=&quot;intro&quot;&gt;&lt;/a&gt;intro&lt;/h1&gt;&lt;p&gt;Configuration 在特殊的“bootstrap”阶段加载到 Spring 环境中。Bootstrap属于引
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql连接错误排查</title>
    <link href="http://yoursite.com/2018/12/07/mysql%E8%BF%9E%E6%8E%A5%E9%94%99%E8%AF%AF%E6%8E%92%E6%9F%A5/"/>
    <id>http://yoursite.com/2018/12/07/mysql连接错误排查/</id>
    <published>2018-12-07T15:09:00.000Z</published>
    <updated>2019-12-08T02:51:23.352Z</updated>
    
    <content type="html"><![CDATA[<p>最近一周，MiotDungBeetleManager和MiotSpecManager偶尔发生数据库连接错误的异常。</p><p>最终得出的结论是：由于我们的DAL层使用了数据库连接池&amp;&amp;我们的业务请求量比较低，导致连接池里的连接与数据库长时间没有通信，连接被数据库关掉了（mysql默认是8小时，连接不通信会被关掉）。但是被关掉的连接没有从连接池里踢掉，这些被关闭的连接与mysql通信时，发生了异常。</p><p>以下是排查过程：</p><p>现象：<br><img src="https://i.loli.net/2019/12/07/qmrt5PoeisJ7EOz.png" alt="image.png"></p><p>找原因：</p><p>1、 查看官方解释</p><blockquote><p>CommunicationsException源码中的解释<br>/**</p><ul><li>An exception to represent communications errors with the database.</li><li></li><li>Attempts to provide ‘friendler’ error messages to end-users, including last time a packet was sent to the database, what the client-timeout is set to, and</li><li>whether the idle time has been exceeded.</li><li>/<br>即是客户端与数据库通信时发发生了错误时抛出该异常。以上这个注释没有明确解释产生该异常的原因。同时官方网站也没有查到相关信息。<br>(异常日志中有以下一段，它表明客户端与数据库通信是OK的。)<br>The last packet successfully received from the server was 2,016 milliseconds ago.  The last packet sent successfully to the server was 2,009 milliseconds ago</li></ul></blockquote><p>2、 Google</p><blockquote><p>大部分的信息都是说发生这个错误一般是由于客户端使的数据库连接由于与数据库长时间没有通信，连接被数据库关闭了。<br>客户端拿着一个实际已被关闭的连接与数据库通信时，会发生CommunicationsException(也许也有其它可能)。以下我们尝试以这个说法来找原因。</p></blockquote><p>讨论以上说法的可能性：<br>MI_DAL的数据库连接池是基于apache GenericObjectPool的封装，查看代码，连接池涉及以下几个重要参数</p><table><thead><tr><th>参数名</th><th>意义</th><th>我们系统的值</th><th>是否能设置</th></tr></thead><tbody><tr><td>testWhileIdle</td><td>是否测试处于idle状态的连接是否还有效</td><td>true</td><td>N</td></tr><tr><td>maxActive</td><td>最大活跃连接数。如果当前活跃连接数已达上限，客户端再尝试从从连接池中取连接时，会抛出异常</td><td>50</td><td>Y</td></tr><tr><td>maxIdle</td><td>允许处于idle状态的最大连接数。当客户端处理完逻辑，往连接池归还连接时，如果连接池中的idle连接已达该值，则该连接会会被直接关闭。</td><td>5</td><td>Y</td></tr><tr><td>numTestsPerEvictionRun</td><td>连接池有一个后台Eviction Timer，定期检查idle状态的连接，如果检测出连接实际上已无效(已被关闭)，则会将该连接踢出连接池。该参数设置的是Timer线程每次执行时，最多能检测几个连接(即并不是是每次运行都把连接池里面的连接都检查一遍)。</td><td>3</td><td>N</td></tr><tr><td>minEvictableIdleTimeMill</td><td>一个连接被归还给连接池多长时间之后，才会被认为处于idle状态&amp;&amp;能够被Eviction Timer检测并踢出连接连接池</td><td>10分钟</td><td>N</td></tr><tr><td>timeBetweenEvictionRunsMillis</td><td>Eviction Timer的运行频率</td><td>12分钟</td><td>N</td></tr><tr><td>testOnBorrow</td><td>是否在每次从连接池里取出连接后都检测连接是否有效。设置为true对性能有一定影响。</td><td>false</td><td>N</td></tr></tbody></table><p>(以上否能设置一列表示Mi_DAL是否有提供入口让我们设置该值)</p><p>要彻底解决从连接池中取到无效连接导致SQL执行失败的问题，需要将testOnBorrow设置为true。但是MI_DAL没有提供设置该参数的入口。</p><p>能够设置的参数只有maxIdle。</p><p>以上参数可能造成的问题：</p><p><code>axIdle(5)&gt; numTestsPerEvictionRun(3)：</code></p><p>假设连接池中现在有5个连接，状态全部是idle。接着，Eviction Timer运行了一次，清理了其中3个(numTestsPerEvictionRun)。接着，来了一个SQL，直接从连接池中取了连接，这个连接实际上可能已经被数据库端关闭了，于是，就发生了以上的异常。</p><p>合理的设置，应该是将numTestsPerEvictionRun设置成&gt;= maxIdle,即每次运行Eviction Timer都可以将所有的idle连接清理出连接池。</p><p>由于numTestsPerEvictionRun不能设置，只能将maxIdle调小为3,以覆盖掉默认值，设置方法</p><p><code>sql.socket.connect.max.idle=3</code></p><p>初步结论：</p><ol><li>通过在JVM的启动参数中设置以下参数，可以降低出异常的可能（或者修改DAL代码，将以上几个参数暴露出来给我设置）<br><code>-Dsql.socket.connect.max.idle=3</code></li><li>Eviction Timer的运行频率是12分钟，在这12分钟内，如果有SQL拿到了实际已被关闭的连接，仍然会发生异常</li><li>只有将testOnBorrow设置为true,才能根绝这个问题</li><li>这个问题发生的概率很低，对线上造成的影响几乎可以忽略</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近一周，MiotDungBeetleManager和MiotSpecManager偶尔发生数据库连接错误的异常。&lt;/p&gt;
&lt;p&gt;最终得出的结论是：由于我们的DAL层使用了数据库连接池&amp;amp;&amp;amp;我们的业务请求量比较低，导致连接池里的连接与数据库长时间没有通信，连接
      
    
    </summary>
    
    
      <category term="Storage" scheme="http://yoursite.com/categories/Storage/"/>
    
    
  </entry>
  
  <entry>
    <title>onos动态扩容实战与源码分析</title>
    <link href="http://yoursite.com/2018/09/26/onos%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E5%AE%9E%E6%88%98%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/09/26/onos动态扩容实战与源码分析/</id>
    <published>2018-09-26T13:13:00.000Z</published>
    <updated>2019-12-08T02:52:31.220Z</updated>
    
    <content type="html"><![CDATA[<p>目前onos的扩容做的还不是很完善，比如onos源码提供了client添加controller的命令实现文件，在”onos/cli/src/main/java/org/onosproject/cli/NodeAddCommand.java”</p><pre><code class="java"><span class="comment">/*</span><span class="comment"> * Copyright 2014-present Open Networking Laboratory</span><span class="comment"> *</span><span class="comment"> * Licensed under the Apache License, Version 2.0 (the "License");</span><span class="comment"> * you may not use this file except in compliance with the License.</span><span class="comment"> * You may obtain a copy of the License at</span><span class="comment"> *</span><span class="comment"> *     http://www.apache.org/licenses/LICENSE-2.0</span><span class="comment"> *</span><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span><span class="comment"> * distributed under the License is distributed on an "AS IS" BASIS,</span><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><span class="comment"> * See the License for the specific language governing permissions and</span><span class="comment"> * limitations under the License.</span><span class="comment"> */</span><span class="keyword">package</span> org.onosproject.cli;<span class="keyword">import</span> org.apache.karaf.shell.commands.Argument;<span class="keyword">import</span> org.apache.karaf.shell.commands.Command;<span class="keyword">import</span> org.onosproject.cluster.ClusterAdminService;<span class="keyword">import</span> org.onosproject.cluster.DefaultControllerNode;<span class="keyword">import</span> org.onosproject.cluster.NodeId;<span class="keyword">import</span> org.onlab.packet.IpAddress;<span class="comment">/**</span><span class="comment"> * Adds a new controller cluster node.</span><span class="comment"> */</span><span class="meta">@Command</span>(scope = <span class="string">"onos"</span>, name = <span class="string">"add-node"</span>,         description = <span class="string">"Adds a new controller cluster node"</span>)<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeAddCommand</span> <span class="keyword">extends</span> <span class="title">AbstractShellCommand</span> </span>{    <span class="meta">@Argument</span>(index = <span class="number">0</span>, name = <span class="string">"nodeId"</span>, description = <span class="string">"Node ID"</span>,              required = <span class="keyword">true</span>, multiValued = <span class="keyword">false</span>)    String nodeId = <span class="keyword">null</span>;    <span class="meta">@Argument</span>(index = <span class="number">1</span>, name = <span class="string">"ip"</span>, description = <span class="string">"Node IP address"</span>,              required = <span class="keyword">true</span>, multiValued = <span class="keyword">false</span>)    String ip = <span class="keyword">null</span>;    <span class="meta">@Argument</span>(index = <span class="number">2</span>, name = <span class="string">"tcpPort"</span>, description = <span class="string">"Node TCP listen port"</span>,              required = <span class="keyword">false</span>, multiValued = <span class="keyword">false</span>)    <span class="keyword">int</span> tcpPort = DefaultControllerNode.DEFAULT_PORT;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>{        ClusterAdminService service = get(ClusterAdminService<span class="class">.<span class="keyword">class</span>)</span>;        service.addNode(<span class="keyword">new</span> NodeId(nodeId), IpAddress.valueOf(ip), tcpPort);    }} </code></pre><p>然而在客户端中是没有这个命令的，也就是他还没有完全实现，所以只能期待后续的完善。</p><p>我们可以在启动onos的时候通过onos-form-cluster命令直接启动一个集群，这个脚本文件的源码如下：</p><pre><code class="bash"><span class="meta">#!/bin/bash</span><span class="comment"># -----------------------------------------------------------------------------</span><span class="comment"># Forms ONOS cluster using REST API of each separate instance.</span><span class="comment"># -----------------------------------------------------------------------------</span>[ <span class="variable">$#</span> -lt 2 ] &amp;&amp; <span class="built_in">echo</span> <span class="string">"usage: <span class="variable">$(basename $0)</span> ip1 ip2..."</span> &amp;&amp; <span class="built_in">exit</span> 1<span class="comment"># Scan arguments for user/password or other options...</span><span class="keyword">while</span> <span class="built_in">getopts</span> u:p:s: o; <span class="keyword">do</span>    <span class="keyword">case</span> <span class="string">"<span class="variable">$o</span>"</span> <span class="keyword">in</span>        u) user=<span class="variable">$OPTARG</span>;;        p) password=<span class="variable">$OPTARG</span>;;        s) partitionsize=<span class="variable">$OPTARG</span>;;    <span class="keyword">esac</span><span class="keyword">done</span>ONOS_WEB_USER=<span class="variable">${ONOS_WEB_USER:-onos}</span> <span class="comment"># ONOS WEB User defaults to 'onos'</span>ONOS_WEB_PASS=<span class="variable">${ONOS_WEB_PASS:-rocks}</span> <span class="comment"># ONOS WEB Password defaults to 'rocks'</span>user=<span class="variable">${user:-$ONOS_WEB_USER}</span>password=<span class="variable">${password:-$ONOS_WEB_PASS}</span><span class="built_in">let</span> OPC=<span class="variable">$OPTIND</span>-1<span class="built_in">shift</span> <span class="variable">$OPC</span>ip=<span class="variable">$1</span><span class="built_in">shift</span>nodes=$*ipPrefix=<span class="variable">${ip%.*}</span>aux=/tmp/<span class="variable">${ipPrefix}</span>.cluster.json<span class="built_in">trap</span> <span class="string">"rm -f <span class="variable">$aux</span>"</span> EXIT<span class="built_in">echo</span> <span class="string">"{ \"nodes\": [ { \"ip\": \"<span class="variable">$ip</span>\" }"</span> &gt; <span class="variable">$aux</span><span class="keyword">for</span> node <span class="keyword">in</span> <span class="variable">$nodes</span>; <span class="keyword">do</span>    <span class="built_in">echo</span> <span class="string">", { \"ip\": \"<span class="variable">$node</span>\" }"</span> &gt;&gt; <span class="variable">$aux</span><span class="keyword">done</span><span class="built_in">echo</span> <span class="string">"], \"ipPrefix\": \"<span class="variable">$ipPrefix</span>.*\""</span> &gt;&gt; <span class="variable">$aux</span><span class="keyword">if</span> ! [ -z <span class="variable">${partitionsize}</span> ]; <span class="keyword">then</span>    <span class="built_in">echo</span> <span class="string">", \"partitionSize\": <span class="variable">$partitionsize</span>"</span> &gt;&gt; <span class="variable">$aux</span><span class="keyword">fi</span><span class="built_in">echo</span> <span class="string">" }"</span> &gt;&gt; <span class="variable">$aux</span><span class="keyword">for</span> node <span class="keyword">in</span> <span class="variable">$ip</span> <span class="variable">$nodes</span>; <span class="keyword">do</span>    <span class="built_in">echo</span> <span class="string">"Forming cluster on <span class="variable">$node</span>..."</span>    curl --user <span class="variable">$user</span>:<span class="variable">$password</span> -X POST \        http://<span class="variable">$node</span>:8181/onos/v1/cluster/configuration -d @<span class="variable">$aux</span><span class="keyword">done</span> </code></pre><p>我们只需要关注最后的实现，其实它只是向每个节点的一个HTTP API接口发送post请求，提交一个配置文件，这个API的实现在这里onos\web\api\src\main\java\org\onosproject\rest\resources\ClusterWebResource.java：</p><pre><code class="java">    <span class="comment">/**</span><span class="comment">     * Forms cluster of ONOS instances.</span><span class="comment">     * Forms ONOS cluster using the uploaded JSON definition.</span><span class="comment">     *</span><span class="comment">     * <span class="doctag">@param</span> config cluster definition</span><span class="comment">     * <span class="doctag">@return</span> 200 OK</span><span class="comment">     * <span class="doctag">@throws</span> IOException to signify bad request</span><span class="comment">     * <span class="doctag">@onos</span>.rsModel ClusterPost</span><span class="comment">     */</span>    <span class="meta">@POST</span>    <span class="meta">@Path</span>(<span class="string">"configuration"</span>)    <span class="meta">@Produces</span>(MediaType.APPLICATION_JSON)    <span class="function"><span class="keyword">public</span> Response <span class="title">formCluster</span><span class="params">(InputStream config)</span> <span class="keyword">throws</span> IOException </span>{        JsonCodec&lt;ControllerNode&gt; codec = codec(ControllerNode<span class="class">.<span class="keyword">class</span>)</span>;        ObjectNode root = (ObjectNode) mapper().readTree(config);        List&lt;ControllerNode&gt; nodes = codec.decode((ArrayNode) root.path(<span class="string">"nodes"</span>), <span class="keyword">this</span>);        JsonNode partitionSizeNode = root.get(<span class="string">"partitionSize"</span>);        <span class="keyword">if</span> (partitionSizeNode != <span class="keyword">null</span>) {            <span class="keyword">int</span> partitionSize = partitionSizeNode.asInt();            <span class="keyword">if</span> (partitionSize == <span class="number">0</span>) {                <span class="keyword">return</span> Response.notAcceptable(<span class="keyword">null</span>).build();            }            get(ClusterAdminService<span class="class">.<span class="keyword">class</span>).<span class="title">formCluster</span>(<span class="title">new</span> <span class="title">HashSet</span>&lt;&gt;(<span class="title">nodes</span>), <span class="title">partitionSize</span>)</span>;        } <span class="keyword">else</span> {            get(ClusterAdminService<span class="class">.<span class="keyword">class</span>).<span class="title">formCluster</span>(<span class="title">new</span> <span class="title">HashSet</span>&lt;&gt;(<span class="title">nodes</span>))</span>;        }        <span class="keyword">return</span> Response.ok().build();    }}</code></pre><p> 在formCluster方法中，首先它会解析Json格式的配置文件，然后进一步调用方法，实现在onos\core\net\src\main\java\org\onosproject\cluster\impl\ClusterManager.java</p><pre><code class="java"><span class="meta">@Override</span><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">formCluster</span><span class="params">(Set&lt;ControllerNode&gt; nodes, <span class="keyword">int</span> partitionSize)</span> </span>{    checkNotNull(nodes, <span class="string">"Nodes cannot be null"</span>);    checkArgument(!nodes.isEmpty(), <span class="string">"Nodes cannot be empty"</span>);    ClusterMetadata metadata = <span class="keyword">new</span> ClusterMetadata(<span class="string">"default"</span>, nodes, buildDefaultPartitions(nodes, partitionSize));    clusterMetadataAdminService.setClusterMetadata(metadata);    <span class="keyword">try</span> {        log.warn(<span class="string">"Shutting down container for cluster reconfiguration!"</span>);        <span class="comment">// Clean up persistent state associated with previous cluster configuration.</span>        Tools.removeDirectory(System.getProperty(<span class="string">"karaf.data"</span>) + <span class="string">"/partitions"</span>);        systemService.reboot(<span class="string">"now"</span>, SystemService.Swipe.NONE);    } <span class="keyword">catch</span> (Exception e) {        log.error(<span class="string">"Unable to reboot container"</span>, e);    }}</code></pre><p>它会更新ClusterMetadata，然后删除apache…/data/partitions目录，最后重启karaf<br>在onos\core\net\src\main\java\org\onosproject\cluster\impl\ClusterMetadataManager.java里，有一个方法：</p><pre><code class="java"><span class="comment">/**</span><span class="comment"> * Returns the primary provider for cluster metadata.</span><span class="comment"> * <span class="doctag">@return</span> primary cluster metadata provider</span><span class="comment"> */</span><span class="comment">//default scheme is file</span><span class="function"><span class="keyword">private</span> ClusterMetadataProvider <span class="title">getPrimaryProvider</span><span class="params">()</span> </span>{    String metadataUri = System.getProperty(<span class="string">"onos.cluster.metadata.uri"</span>);    <span class="keyword">try</span> {        String protocol = metadataUri == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> URL(metadataUri).getProtocol();        <span class="keyword">if</span> (protocol != <span class="keyword">null</span> &amp;&amp; (!protocol.equals(<span class="string">"file"</span>) &amp;&amp; !protocol.equals(<span class="string">"http"</span>))) {            <span class="keyword">return</span> getProvider(protocol);        }        <span class="comment">// file provider supports both "file" and "http" uris</span>        <span class="keyword">return</span> getProvider(<span class="string">"file"</span>);    } <span class="keyword">catch</span> (MalformedURLException e) {        <span class="keyword">return</span> <span class="keyword">null</span>;    }}</code></pre><p> 这个方法会获取”onos.cluster.metadata.uri”属性，判断是file还是http，默认情况下是file，指向安装目录下config/cluster.json文件，也就是说，onos关于集群的管理是基于这个配置文件，我们可以从onos\core\net\src\main\java\org\onosproject\cluster\impl\ConfigFileBasedClusterMetadataProvider.java中看出，onos会不断扫描这个文件，更新我们的配置，如果我们把”onos.cluster.metadata.uri”指向一个可以访问到的url，onos就会开启一个输入流不断读取。所以一个比较好的方法是，在一台机器上开启一个server服务，让其它onos集群都来访问这个api，否则只能一个个手动更换每台机器的配置文件。</p><p>与onos集群相关的代码还有onos\core\store\primitives\src\main\java\org\onosproject\store\primitives\impl\PartitionManager、onos\core\store\primitives\src\main\java\org\onosproject\store\primitives\impl\StorageManager、onos\core\api\src\main\java\org\onosproject\cluster\ClusterMetadataDiff.java等</p><p>onos目前还不支持partition扩容，所以partition是不能修改的，只能增加每个partition的member数，看到官方开发人员说有可能会在1.12版本上这个功能。。</p><p>这里我们以3台扩5台为例</p><p>1、首先要修改每台机器的”onos.cluster.metadata.uri”，只需在bin目录下onos-service添加下面加粗的一行就好</p><pre><code class="bash"><span class="meta">#!/bin/bash</span><span class="comment"># -----------------------------------------------------------------------------</span><span class="comment"># Starts ONOS Apache Karaf container</span><span class="comment"># -----------------------------------------------------------------------------</span><span class="comment"># uncomment the following line for performance testing</span><span class="comment">#export JAVA_OPTS="${JAVA_OPTS:--Xms8G -Xmx8G -XX:+UseConcMarkSweepGC -XX:+CMSIncrementalMode -XX:+PrintGCDetails -XX:+PrintGCTimeStamps}"</span><span class="comment"># uncomment the following line for Netty TLS encryption</span><span class="comment"># Do modify the keystore location/password and truststore location/password accordingly</span><span class="comment">#export JAVA_OPTS="${JAVA_OPTS:--DenableNettyTLS=true -Djavax.net.ssl.keyStore=/home/ubuntu/onos.jks -Djavax.net.ssl.keyStorePassword=222222 -Djavax.net.ssl.trustStore=/home/ubuntu/onos.jks -Djavax.net.ssl.trustStorePassword=222222}"</span><span class="built_in">export</span> JAVA_OPTS=<span class="variable">${JAVA_OPTS:--Donos.cluster.metadata.uri=http://10.97.25.221:5000/cluster.json}</span><span class="comment">#在这里，指向你的服务地址</span><span class="built_in">set</span> -e  <span class="comment"># exit on error</span><span class="built_in">set</span> -u  <span class="comment"># exit on undefined variable</span><span class="comment"># If ONOS_HOME is set, respect its value.</span><span class="comment"># If ONOS_HOME is not set (e.g. in the init or service environment),</span><span class="comment"># set it based on this script's path.</span>ONOS_HOME=<span class="variable">${ONOS_HOME:-$(cd $(dirname $0)/.. &gt;/dev/null 2&gt;&amp;1 &amp;&amp; pwd)}</span>KARAF_ARGS=SYS_APPS=driversONOS_APPS=<span class="variable">${ONOS_APPS:-}</span>  <span class="comment"># Empty means don't activate any new apps</span><span class="built_in">cd</span> <span class="variable">$ONOS_HOME</span><span class="comment"># Parse out arguments destinted for karaf invocation v. arguments that</span><span class="comment"># will be processed in line</span><span class="keyword">while</span> [ <span class="variable">$#</span> -gt 0 ]; <span class="keyword">do</span>  <span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span>    apps-clean)      <span class="comment"># Deactivate all applications</span>      find <span class="variable">${ONOS_HOME}</span>/apps -name <span class="string">"active"</span> -<span class="built_in">exec</span> rm \{\} \;      ;;    *)      KARAF_ARGS+=<span class="string">" <span class="variable">$1</span>"</span>      ;;  <span class="keyword">esac</span>  <span class="built_in">shift</span><span class="keyword">done</span><span class="comment"># Activate the system required applications (SYS_APPS) as well as any</span><span class="comment"># specified applications in the var ONOS_APPS</span><span class="keyword">for</span> app <span class="keyword">in</span> <span class="variable">${SYS_APPS//,/ }</span> <span class="variable">${ONOS_APPS//,/ }</span>; <span class="keyword">do</span>    <span class="keyword">if</span>  [ -d <span class="string">"<span class="variable">${ONOS_HOME}</span>/apps/org.onosproject.<span class="variable">$app</span>/"</span> ]; <span class="keyword">then</span>        touch <span class="variable">${ONOS_HOME}</span>/apps/org.onosproject.<span class="variable">$app</span>/active    <span class="keyword">elif</span> [ -d <span class="string">"<span class="variable">${ONOS_HOME}</span>/apps/<span class="variable">$app</span>"</span> ]; <span class="keyword">then</span>        touch <span class="variable">${ONOS_HOME}</span>/apps/<span class="variable">$app</span>/active    <span class="keyword">else</span>        <span class="built_in">echo</span> <span class="string">"[WARN] Don't know how to activate <span class="variable">$app</span>"</span>    <span class="keyword">fi</span><span class="keyword">done</span><span class="built_in">exec</span> <span class="variable">${ONOS_HOME}</span>/apache-karaf-3.0.8/bin/karaf <span class="variable">$KARAF_ARGS</span></code></pre><p>这样，onos启动后就会直接从这个地址获取配置文件</p><p>2、启动配置管理服务，这里我用python -m SimpleHTTPServer 5000起了个简单的server</p><p>3、修改cluster.json文件，三台时的配置文件如下</p><pre><code class="json">{  <span class="attr">"name"</span>: <span class="string">"default"</span>,  <span class="attr">"nodes"</span>: [    {      <span class="attr">"id"</span>: <span class="string">"172.17.0.7"</span>,      <span class="attr">"ip"</span>: <span class="string">"172.17.0.7"</span>,      <span class="attr">"port"</span>: <span class="number">9876</span>    },    {      <span class="attr">"id"</span>: <span class="string">"172.17.0.8"</span>,      <span class="attr">"ip"</span>: <span class="string">"172.17.0.8"</span>,      <span class="attr">"port"</span>: <span class="number">9876</span>    },    {      <span class="attr">"id"</span>: <span class="string">"172.17.0.9"</span>,      <span class="attr">"ip"</span>: <span class="string">"172.17.0.9"</span>,      <span class="attr">"port"</span>: <span class="number">9876</span>    }  ],  <span class="attr">"partitions"</span>: [    {      <span class="attr">"id"</span>: <span class="number">1</span>,      <span class="attr">"members"</span>: [        <span class="string">"172.17.0.7"</span>,        <span class="string">"172.17.0.8"</span>,        <span class="string">"172.17.0.9"</span>      ]    },    {      <span class="attr">"id"</span>: <span class="number">2</span>,      <span class="attr">"members"</span>: [        <span class="string">"172.17.0.9"</span>,        <span class="string">"172.17.0.7"</span>,        <span class="string">"172.17.0.8"</span>      ]    },    {      <span class="attr">"id"</span>: <span class="number">3</span>,      <span class="attr">"members"</span>: [        <span class="string">"172.17.0.8"</span>,        <span class="string">"172.17.0.9"</span>,        <span class="string">"172.17.0.7"</span>      ]    }  ]}由于partition不能扩充，所以升到5台的配置文件如下{  <span class="attr">"name"</span>: <span class="string">"default"</span>,  <span class="attr">"nodes"</span>: [    {      <span class="attr">"id"</span>: <span class="string">"172.17.0.7"</span>,      <span class="attr">"ip"</span>: <span class="string">"172.17.0.7"</span>,      <span class="attr">"port"</span>: <span class="number">9876</span>    },    {      <span class="attr">"id"</span>: <span class="string">"172.17.0.8"</span>,      <span class="attr">"ip"</span>: <span class="string">"172.17.0.8"</span>,      <span class="attr">"port"</span>: <span class="number">9876</span>    },    {      <span class="attr">"id"</span>: <span class="string">"172.17.0.9"</span>,      <span class="attr">"ip"</span>: <span class="string">"172.17.0.9"</span>,      <span class="attr">"port"</span>: <span class="number">9876</span>    },    {      <span class="attr">"id"</span>: <span class="string">"172.17.0.10"</span>,      <span class="attr">"ip"</span>: <span class="string">"172.17.0.10"</span>,      <span class="attr">"port"</span>: <span class="number">9876</span>    },    {      <span class="attr">"id"</span>: <span class="string">"172.17.0.11"</span>,      <span class="attr">"ip"</span>: <span class="string">"172.17.0.11"</span>,      <span class="attr">"port"</span>: <span class="number">9876</span>    }  ],  <span class="attr">"partitions"</span>: [    {      <span class="attr">"id"</span>: <span class="number">1</span>,      <span class="attr">"members"</span>: [        <span class="string">"172.17.0.7"</span>,        <span class="string">"172.17.0.8"</span>,        <span class="string">"172.17.0.9"</span>,        <span class="string">"172.17.0.10"</span>,        <span class="string">"172.17.0.11"</span>      ]    },    {      <span class="attr">"id"</span>: <span class="number">2</span>,      <span class="attr">"members"</span>: [        <span class="string">"172.17.0.11"</span>,        <span class="string">"172.17.0.7"</span>,        <span class="string">"172.17.0.8"</span>,        <span class="string">"172.17.0.9"</span>,        <span class="string">"172.17.0.10"</span>      ]    },    {      <span class="attr">"id"</span>: <span class="number">3</span>,      <span class="attr">"members"</span>: [        <span class="string">"172.17.0.10"</span>,        <span class="string">"172.17.0.11"</span>,        <span class="string">"172.17.0.7"</span>,        <span class="string">"172.17.0.8"</span>,        <span class="string">"172.17.0.9"</span>      ]    }  ]}</code></pre><p>4、最后启动我们要添加的两台onos机器，剩下的就会自动同步好 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目前onos的扩容做的还不是很完善，比如onos源码提供了client添加controller的命令实现文件，在”onos/cli/src/main/java/org/onosproject/cli/NodeAddCommand.java”&lt;/p&gt;
&lt;pre&gt;&lt;code c
      
    
    </summary>
    
    
      <category term="Distribute" scheme="http://yoursite.com/categories/Distribute/"/>
    
    
  </entry>
  
  <entry>
    <title>Raft协议为何只能有奇数个节点</title>
    <link href="http://yoursite.com/2018/09/07/Raft%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BD%95%E5%8F%AA%E8%83%BD%E6%9C%89%E5%A5%87%E6%95%B0%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2018/09/07/Raft协议为何只能有奇数个节点/</id>
    <published>2018-09-07T13:05:00.000Z</published>
    <updated>2019-12-07T13:12:39.630Z</updated>
    
    <content type="html"><![CDATA[<p>ONOS系统1.4版本以后使用Atomix作为分布式协调框架，因而使用RAFT协议保证一致性。其中有一个要求是集群中节点数必须为奇数个。查了一下没找到原因，思考了一下，想到了一点是这样可以解决split-brain问题。这样当网络故障发生时，无论集群怎么切分始终能保持有一半能获得多数确认，从而保证正常commit，待网络恢复后，再进行同步。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ONOS系统1.4版本以后使用Atomix作为分布式协调框架，因而使用RAFT协议保证一致性。其中有一个要求是集群中节点数必须为奇数个。查了一下没找到原因，思考了一下，想到了一点是这样可以解决split-brain问题。这样当网络故障发生时，无论集群怎么切分始终能保持有一半
      
    
    </summary>
    
    
      <category term="Distribute" scheme="http://yoursite.com/categories/Distribute/"/>
    
    
  </entry>
  
  <entry>
    <title>Go range函数踩坑</title>
    <link href="http://yoursite.com/2018/08/29/Go-range%E5%87%BD%E6%95%B0%E8%B8%A9%E5%9D%91/"/>
    <id>http://yoursite.com/2018/08/29/Go-range函数踩坑/</id>
    <published>2018-08-29T14:48:00.000Z</published>
    <updated>2019-12-08T02:53:10.055Z</updated>
    
    <content type="html"><![CDATA[<p>range函数返回的是变量的副本，而不是引用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">   a = <span class="built_in">append</span>(a, <span class="number">1</span>)</span><br><span class="line">   a = <span class="built_in">append</span>(a, <span class="number">1</span>)</span><br><span class="line">   a = <span class="built_in">append</span>(a, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">   fmt.Println(a)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> _, value := <span class="keyword">range</span> a &#123;</span><br><span class="line">      value = <span class="number">2</span></span><br><span class="line">      fmt.Println(value)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这段代码slice a的值并不会真正修改，输出结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[1 1 1]</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">[1 1 1]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;range函数返回的是变量的副本，而不是引用&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li
      
    
    </summary>
    
    
      <category term="Go" scheme="http://yoursite.com/categories/Go/"/>
    
    
  </entry>
  
  <entry>
    <title>getContextPath、getServletPath、getRequestURI的区别</title>
    <link href="http://yoursite.com/2018/08/24/getContextPath%E3%80%81getServletPath%E3%80%81getRequestURI%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/08/24/getContextPath、getServletPath、getRequestURI的区别/</id>
    <published>2018-08-24T14:51:00.000Z</published>
    <updated>2019-12-08T02:53:23.005Z</updated>
    
    <content type="html"><![CDATA[<p>假定你的web application 名称为news,你在浏览器中输入请求路径：<br><a href="http://localhost:8080/news/main/list.jsp" target="_blank" rel="noopener">http://localhost:8080/news/main/list.jsp</a><br>则执行下面向行代码后打印出如下结果： </p><ol><li>System.out.println(request.getContextPath()); //可返回站点的根路径。也就是项目的名字<br>打印结果：/news </li><li>System.out.println(request.getServletPath());<br>打印结果：/main/list.jsp </li><li>System.out.println(request.getRequestURI());<br>打印结果：/news/main/list.jsp </li><li>System.out.println(request.getRealPath(“/“));<br>打印结果：F:\Tomcat 6.0\webapps\news\test </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;假定你的web application 名称为news,你在浏览器中输入请求路径：&lt;br&gt;&lt;a href=&quot;http://localhost:8080/news/main/list.jsp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://loc
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>解决docker与主机时间不一致</title>
    <link href="http://yoursite.com/2018/06/07/%E8%A7%A3%E5%86%B3docker%E4%B8%8E%E4%B8%BB%E6%9C%BA%E6%97%B6%E9%97%B4%E4%B8%8D%E4%B8%80%E8%87%B4/"/>
    <id>http://yoursite.com/2018/06/07/解决docker与主机时间不一致/</id>
    <published>2018-06-07T15:03:00.000Z</published>
    <updated>2019-12-07T15:07:37.713Z</updated>
    
    <content type="html"><![CDATA[<p>1、共享主机时间</p><p>创建容器的时候指定启动参数，挂载localtime文件到容器内  ，保证两者所采用的时区是一致的。</p><p>```<br>docker run –name <name> -v /etc/localtime:/etc/localtime:ro ….<br>2、复制主机时间</p><p>docker cp /etc/localtime:【容器ID或者NAME0】/etc/localtime<br>3、Dockerfile中自定义</p><p>FROM redis</p><p>FROM tomcat</p><p>ENV CATALINA_HOME /usr/local/tomcat</p><p>#设置时区<br>RUN /bin/cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime <br>  &amp;&amp; echo ‘Asia/Shanghai’ &gt;/etc/timezone \</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、共享主机时间&lt;/p&gt;
&lt;p&gt;创建容器的时候指定启动参数，挂载localtime文件到容器内  ，保证两者所采用的时区是一致的。&lt;/p&gt;
&lt;p&gt;```&lt;br&gt;docker run –name &lt;name&gt; -v /etc/localtime:/etc/localtime:
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/04/21/hello-world/"/>
    <id>http://yoursite.com/2018/04/21/hello-world/</id>
    <published>2018-04-21T12:46:00.000Z</published>
    <updated>2019-12-07T15:03:15.088Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
      <category term="Other" scheme="http://yoursite.com/categories/Other/"/>
    
    
  </entry>
  
</feed>
